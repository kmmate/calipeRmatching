% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calipeRmatching.R
\name{cm_cm_known_propscore}
\alias{cm_cm_known_propscore}
\title{Caliper matching estimator for known propensity score.}
\usage{
cm_cm_known_propscore(
  y,
  d,
  propscore,
  delta,
  estimate_variance = TRUE,
  beta = 1/4.000000001,
  alpha = 1/4.000000002,
  kappa_a = 10^(-15),
  kappa_gamma = 0.2
)
}
\arguments{
\item{y}{\eqn{n}-long \code{numeric} \code{vector} \eqn{ (Y_1,Y_2,\ldots,Y_n) } of observations of the outcome variable.}

\item{d}{\eqn{n}-long \code{numeric} \code{vector} \eqn{ (D_1,D_2,\ldots,D_n) } of observations of the treatment indicator
variable. Each entry can be either 0 for control or 1 for treatment status.}

\item{propscore}{\eqn{n}-long \code{numeric} \code{vector} \eqn{ (\pi(X_1),\pi(X_2),\ldots,\pi(X_n)) } of observations of the propensity score.}

\item{delta}{the caliper, a positive \code{numeric} variable. If zero is passed, then the default 
data-driven value is used (recommended). If a positive value is passed, that is used instead.}

\item{estimate_variance}{\code{logical} variable. If \code{TRUE}, the variances of the estimators are estimated.
If \code{FALSE}, no variance estimates are provided; this is useful to speed up execution.}

\item{beta}{a positive \code{numeric} variable, negative-exponent of bandwidth sequence \code{gamma_n} = \code{kappa_gamma} * \eqn{n} ^ (-\code{beta}) in nonparametric variance estimation. 
If zero  is passed, it is the default value (recommended), otherwise it is equal to the passed value.}

\item{alpha}{a positive \code{numeric} variable, negative-exponent of truncation sequence \code{a_n} = \code{kappa_a} * \eqn{n} ^ (-\code{alpha}) in nonparametric variance estimation. 
If zero  is passed, it is the default value (recommended), otherwise it is equal to the passed value. 
Must be strictly smaller than \code{beta}.}

\item{kappa_a}{a positive \code{numeric} variable, scale of truncation sequence \code{a_n} = \code{kappa_a} * \eqn{n} ^ (-\code{alpha}) in nonparametric variance estimation. 
If zero  is passed, it is the default value, otherwise it is equal to the passed value.}

\item{kappa_gamma}{a positive \code{numeric} variable, scale of bandwidth sequence \code{gamma_n} = \code{kappa_gamma} * \eqn{n} ^ (-\code{beta}) in nonparametric variance estimation. 
If zero is passed, it is the default value, otherwise it is equal to the passed value.}
}
\value{
A \code{List}, results from caliper matching estimation with elements:
\itemize{
\item \code{point_estimates}: a \code{List} with elements \itemize{ 
     \item \code{ate_hat}: estimated ATE; \eqn{\hat{\tau}_{\pi}} in [KPV23].
     \item \code{att_hat}: estimated ATT; \eqn{\hat{\tau}_{t,\pi}} in [KPV23].
     \item \code{var_hat_ate}: estimated asymptotic variance of \code{ate_hat}; \eqn{ \hat{V}_{\tau} + \hat{V}_{\sigma,\pi} } in [KPV23].
     \item \code{var_hat_att}: estimated asymptotic variance of \code{att_hat}; \eqn{ \hat{V}_{\tau_{t}} + \hat{V}_{t,\sigma,\pi} } in [KPV23].
     \item \code{var_hat_component_tau_ate}: the estimate \eqn{ \hat{V}_{\tau} } in [KPV23].
     \item \code{var_hat_component_tau_att}: the estimate \eqn{ \hat{V}_{\tau_{t}} } in [KPV23].
     \item \code{var_hat_component_sigmapi_ate}: the estimate \eqn{ \hat{V}_{\sigma,\pi} } in [KPV23].
     \item \code{var_hat_component_sigmapi_att}: the estimate \eqn{ \hat{V}_{t,\sigma,\pi} } in [KPV23].
     }
\item \code{delta}: caliper that is actually used. If zero was passed, then it is equal to the default data-driven value \eqn{\overline{\underline{\Delta}}_n \vee \frac{\log N_0}{N_0+1} \vee \frac{\log N_1}{N_1+1}} in the notation of Equation (3) in [KPV23].
                    If a positive value was passed, then it is equal to that instead.
\item \code{number_of_matches}: \eqn{n}-long \code{vector}, the number of matches for each unit.
\item \code{matched_pairs}: a 2-by-(number of matched pairs) \code{matrix}. A column with value \eqn{(i,j)} indicates that units \eqn{i} and \eqn{j} are matched. Indices start from 1, as opposed to from 0.  
\item \code{var_estimation_settings}: a \code{List} with elements \itemize{
     \item \code{estimate_variance}: whether variance estimation is performed (\code{estimate_variance=TRUE}), or not (\code{estimate_variance=FALSE}).
     \item \code{a_n}: value of truncation sequence in nonparametric variance estimation. Equal to \code{kappa_a} * \eqn{n} ^ (-\code{alpha}).
     \item \code{gamma_n}:  value of bandwidth in nonparametric variance estimation. Equal to \code{kappa_gamma} * \eqn{n} ^ (-\code{beta}).
     \item \code{beta}: negative-exponent of bandwidth sequence in nonparametric variance estimation that is actually used. If zero was passed, it is the default value, otherwise it is equal to the passed value.
     \item \code{alpha}: negative-exponent of truncation sequence in nonparametric variance estimation that is actually used. If zero was passed, it is the default value, otherwise it is equal to the passed value.
     \item \code{kappa_gamma}: scale of bandwidth sequence in nonparametric variance estimation that is actually used. If zero was passed, it is the default value, otherwise it is equal to the passed value.
     \item \code{kappa_a}: scale of truncation sequence in nonparametric variance estimation that is actually used. If zero was passed, it is the default value, otherwise it is equal to the passed value.
     \item \code{propscore_min}: the smallest propensity score value in \code{propscore}.
     \item \code{propscore_max}: the largest propensity score value in \code{propscore}.
     \item \code{truncation_low}: lower truncation threshold for variance estimation = \code{propscore_min} + \code{a_n}.
     \item \code{truncation_high}: higher truncation threshold for variance estimation = \code{propscore_max} - \code{a_n}.
     }
}
}
\description{
Estimates the Average Treatment Effect (ATE) 
and Average Treatment Effect on the Treated (ATT) of a binary treatment \eqn{D}
on an outcome \eqn{Y} using the caliper matching estimator and the known propensity score \eqn{\pi(X)}.
 It can also estimate the variances of these two matching estimators.
}
\section{Warning}{
 

It is advised to look at the variance components in the returned results. 
Undesirably, negative values may occur; this may indicate too strong truncation at the bounderies.
To resolve this, lower \code{kappa_a} to mitigate truncation. 
Alternatively, try adjusting \code{kappa_gamma}.
}

\section{Notes}{
 
Asymptotically valid \eqn{100(1-a)\%} confidence intervals can be constructed for
\itemize{
  \item ATE as
     [\code{ate_hat - qnorm(1-a/2) * sqrt(var_hat_ate/n)}, 

      \code{ate_hat + qnorm(1-a/2) * sqrt(var_hat_ate/n)}];
   \item ATT as
     [\code{att_hat - qnorm(1-a/2) * sqrt(var_hat_att/n)},

      \code{att_hat + qnorm(1-a/2) * sqrt(var_hat_att/n)}],
  }
where \code{qnorm} is the standard normal quantile function in \code{R} and \eqn{a} is some user-specified value in the interval \eqn{(0,1)}.
}

\examples{

###############################################################################
# Load package
###############################################################################
library("calipeRmatching")
cm_set_number_of_threads(1) # set number of parallel threads

###############################################################################
# Generate data
###############################################################################
# --- x
# generate n-by-k covariate matrix.
generate_x <- function(n, k){
  x <- array(0, dim=c(n, k))
  for (i in 1:n){
    for (j in 1:k){
      x[i, j] <- runif(1, min=-10, max=10) # Uniform[-10,10] covariates
    }
  }
  return(x)
}
# --- propensity score
# computes propensity score based on logistic model
compute_propscore <- function(x, theta, modeltype){#' 
  stopifnot(ncol(x)==2) # k=2 is assumed
  stopifnot(length(theta)== (2 + 1)) # k=2 is assumed
  stopifnot(modeltype == "logit") # logit model is assumed
  n <- nrow(x)
  k <- ncol(x)
 score <- vector(mode="numeric", n) # X*theta
  propscore <- vector(mode="numeric", n) # g(X*theta)
  for (i in 1:n){
    score_i = theta[1] # intercept
    for (j in 2:(k+1)){
      score_i <- score_i + theta[j] * x[i, j-1]
    }
    score[i] <- score_i
    propscore[i] <- plogis(score_i) # g(x_i^T*theta) propensity score
  }
  return(propscore)
}
# --- treatment
# generates treatment vector
generate_d <- function(propscore){
  n <- length(propscore)
  d <- vector(mode="numeric", n)
  for (i in 1:n){
    d[i] <- rbinom(1, 1, propscore[i]) # D_i | X_i ~ Bernoulli(g(X_i^T*theta))
  }
  return(d)
}
# --- outcome
# generates outcome y
generate_y <- function(x, d){
  n <- nrow(x)
  stopifnot(ncol(x)==2) # k=2 is assumed
  y <- vector(mode="numeric", n)
  mu0 <- 0.0
  mu1 <- 0.0 # imply ATE = mu1 - mu0 if E[X] = 0_k
  for (i in 1:n){
    y0i <- mu0 + 0.8 * x[i, 1] + 1.5 * x[i, 2] + 0.9 * rnorm(n=1)
    y1i <- mu1 + 3.1 * sin(x[i, 1]) - 1.8 * x[i, 2] + 1.1 * rnorm(n=1)
    y[i] <- y0i + d[i] * (y1i - y0i)
  }
  return(y) 
}
n <- 5000
k <- 2 # if changed, theta and the way that `y` is generated must  be changed too.
modeltype <- "logit" # if changed, the way that `propscore` is generated must be changed too.
theta <- c(0.004, 0.5, 0.2) # propensity score parameters; first entry is intercept
# generate data
x <- generate_x(n, k)
propscore <- compute_propscore(x, theta, modeltype)
d <- generate_d(propscore)
y <- generate_y(x, d)

###############################################################################
# Estimation (known propensity score)
###############################################################################

# test library
test_cm()

# estimation
delta <- 0.0 # caliper; set to zero for default value
estimate_variance <- TRUE # do estimate variance
alpha <- 0.0
beta <- 0.0
kappa_a <- 0.0
kappa_gamma <- 0.0
# for categorical treatment indicator use # d <- as.numeric(d=="string_for_treated") 
help("cm_cm_known_propscore")
result_known_propscore <- cm_cm_known_propscore(y, d, propscore, delta, estimate_variance,
                                                beta, alpha, kappa_a, kappa_gamma)
print(result_known_propscore)
ate_hat <- result_known_propscore$point_estimates$ate_hat
var_hat_ate <- result_known_propscore$point_estimates$var_hat_ate
ate_ci95_low <- ate_hat - qnorm(0.975) * sqrt(var_hat_ate/length(y))
ate_ci95_high <- ate_hat + qnorm(0.975) * sqrt(var_hat_ate/length(y))
print(sprintf("95\%\% asymptotically valid confidence interval for ATE: [\%f, \%f]",
              ate_ci95_low, ate_ci95_high))

}
\references{
[KPV23] Kormos, V. d. Pas, V. d. Vaart (2023): Asymptotics of Caliper Matching Estimators for Average Treatment Effects, https://arxiv.org/abs/2304.08373
}
\seealso{
\code{\link{cm_cm_estimated_propscore}}
}
\author{
Mate Kormos
}
